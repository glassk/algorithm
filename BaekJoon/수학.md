### #10430 나머지

```python
if __name__ == "__main__":
    a, b, c = map(int, input().split())
    print((a+b) % c)
    print(((a % c)+(b % c)) % c)
    print((a*b) % c)
    print(((a % c)*(b % c)) % c)
```



### #2609 최대공약수와 최소공배수

```python
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


def lcm(a, b):
    return int(a*b / gcd(a, b))


if __name__ == "__main__":
    a, b = map(int, input().split())
    print(gcd(a, b))
    print(lcm(a, b))
```

- 유클리드 호제법
  - a와 b 중 큰 수를 c, 작은 수를 d라고 했을 때 c를 d로 나눈 나머지를 temp라고하자. c와 d의 최대공약수는 d와 temp의 최대공약수와 같다. temp가 0이 될 때까지 반복적으로 c와 d를 d와 temp로 업데이트하면 최종적으로 c가 최대공약수이다.
  - 최소공배수는 a와 b의 곱을 a와 b의 최대공약수로 나눈 값이다.



### #1934 최소공배수

```python
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


def lcm(a, b):
    return int(a*b / gcd(a, b))


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        a, b = map(int, input().split())
        print(lcm(a, b))
```



### #1850 최대공약수

```python
# ref
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


if __name__ == "__main__":
    a, b = map(int, input().split())
    print('1'*gcd(a, b))
```

[참고](https://claude-u.tistory.com/404)

- a와 b개의 1로만 이뤄져 있는 수 그 자체로 최대공약수를 구하면 메모리 초과 에러 발생
- 직접 구하지 않고 두 수의 1의 개수(a와 b)끼리의 최대공약수만 구하면 된다!



### #9613 GCD 합

```python
def gcd(a, b):
    c, d = max(a, b), min(a, b)
    temp = 1
    while temp > 0:
        temp = c % d
        c, d = d, temp
    return c


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        nums = list(map(int, input().split()))
        total = 0
        n = nums[0]
        for i in range(1, n):
            for j in range(i+1, n+1):
                total += gcd(nums[i], nums[j])
        print(total)
```



### #1978 소수 찾기

```python
def isPrime(num):
    if num == 1:
        return False
    for i in range(2, num):
        if num % i == 0:
            return False
    else:
        return True


def solution(nums):
    answer = 0
    for num in nums:
        if isPrime(num):
            answer += 1
    return answer


if __name__ == "__main__":
    n = int(input())
    nums = list(map(int, input().split()))
    print(solution(nums))
```



### #1929 소수 구하기

```python
# 에라토스테네스의 체
def solution(m, n):
    nums = set(range(2, n+1))
    for i in range(2, n+1):
        if i in nums:
            nums -= set(range(2*i, n+1, i))
    return sorted(nums)


if __name__ == "__main__":
    m, n = map(int, input().split())
    for x in solution(m, n):
        if x >= m:
            print(x)
```

```python
# 소수인지 판별하는 함수에서 num의 제곱근까지만 검사하기
def isPrime(num):
    if num == 1:
        return False
    for i in range(2, int(num**0.5)+1):
        if num % i == 0:
            return False
    else:
        return True


def solution(m, n):
    for i in range(m, n+1):
        if isPrime(i):
            print(i)


if __name__ == "__main__":
    m, n = map(int, input().split())
    solution(m, n)
```

- 첫번째 방법과 두번째 방법을 비교했을 때 전자가 후자보다 메모리는 훨씬 덜 차지하지만 시간이 훨씬 많이 걸린다.. 어떤 게 더 나은 방법일까? 일단은 둘 다 알고 있기..

- 소수 판별할 때 제곱근까지만 검사해도 유효하다.



### #6588 골드바흐의 추측

```python
import sys


def isPrime(n):
    if n == 1:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True


def solution(n):
    for i in range(3, n//2+1, 2):
        a = i
        b = n-i
        if isPrime(a) and isPrime(b):
            return f'{n} = {a} + {b}'
    else:
        return "Goldbach's conjecture is wrong."


if __name__ == "__main__":
    while True:
        n = int(sys.stdin.readline())
        if n == 0:
            break
        print(solution(n))
```

- n 만들 수 있는 방법이 여러 가지이면 b-a가 가장 큰 걸 출력
  - 하나는 가장 작은 것부터, 나머지 하나는 가장 큰 숫자부터 탐색
  - n은 항상 짝수이고 홀수인 소수라는 점을 고려

- [n에 따라 미리 에라토스테네스의 체로 소수들을 모두 구한 후 탐색하는 방식](https://yoonsang-it.tistory.com/52)도 있다
  - 메모리는 2배 더 많이 들지만 시간은 3배 정도 짧다..!



### #11653 소인수분해

```python
# ref
import sys


def solution(n):
    num = 2
    while True:
        if n % num == 0:
            print(num)
            n //= num
        elif n == 1:
            break
        else:
            num += 1


if __name__ == "__main__":
    n = int(sys.stdin.readline())
    if n == 1:
        print('')
    else:
        solution(n)
```

[참고](https://velog.io/@cosmos/BOJ%EB%B0%B1%EC%A4%80-11653-python)

- n까지의 모든 소수에 대하여 적용하는 방식으로 했었는데, 메모리/시간 초과가 났었다
- if 조건문에서 나눠 떨어지는지 검사, n이 1이면 break
  - 두 경우에 해당하지 않으면 1을 더함
